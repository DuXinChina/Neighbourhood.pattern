
  Scale.dependence.Wei_S.mult=function(a,b,scale,MI)
  {
    library(tcltk)  
    library(sp)
    library(gstat)
    Scale.dependence.Wei_S.single=function(a,b,scale,MI)
    {
      ######加载尺度依赖荫蔽度函数
      Scale.dependence.S.single=function(a,b,scale,MI)
      {
        Neighbourhood.single1=function(a,b,scale)###找出一定尺度内的邻体         
        {#3
          c=b[,1:2]
          for (i in 1:nrow(b))
          {#4
            c[i,]=(b[i,1:2]-a[1,1:2])^2
            d=(c[,1]+c[,2])^(1/2)
          }#4 
          d=cbind(b,d)
          #d=subset(d,d>0)
          d=subset(d,d<scale)
          colnames(d) = c("x","Y","Size","Distance")
          d
        }
        Nei.tree=Neighbourhood.single1(a,b,scale)
        n=nrow(Nei.tree)
        Nei.dif.high=cbind(Nei.tree,Nei.tree[,3]-a[,3])
        colnames(Nei.dif.high) = c("x","Y","Size","Distance","Size_dif ")
        n.dif=subset(Nei.dif.high,Nei.dif.high$Size_dif>0)
        n.dif=nrow(n.dif)
        if(n.dif==0)
        {Scale_dependence_S=0
        Neighbourhood=Nei.dif.high}
        if(n.dif!=0)
        {
          Neighbourhood=Nei.dif.high
          Neighbourhood1=Neighbourhood
          Neighbourhood[which(Neighbourhood[,5]<=0),5]=NA
          Neighbourhood1[which(Neighbourhood1[,5]<=0),5]=0
          Neighbourhood1[which(Neighbourhood1[,4]==0),4]=0.00000001
          S1=Neighbourhood1[,5]/Neighbourhood1[,4]
          S2=as.data.frame(S1)
          S=sum(S2,na.rm=T)
          Scale_dependence_S=S
        }
        Scale_dependence_S=(atan( Scale_dependence_S/(MI*pi))/pi*2)
        outcome=list(a=a,Neighbourhood=Neighbourhood,Scale_dependence_S=Scale_dependence_S)
        outcome
      }
      Scale.dependence.Simpson=function(a,b,scale)
      {
        Neighbourhood.single1=function(a,b,scale)###找出一定尺度内的邻体         
        {#3
          
          c=b[,1:2]
          for (i in 1:nrow(b))
          {#4
            c[i,]=(b[i,1:2]-a[1,1:2])^2
            d=(c[,1]+c[,2])^(1/2)
          }#4 
          d=cbind(b,d)
          d=subset(d,d>0)
          d=subset(d,d<scale)
          colnames(d) = c("x","y","Size","Distance")
          d
        }
        Nei.tree=Neighbourhood.single1(a,b,scale)
        Nei.tree
        Nei.tree[,3]=Nei.tree[,3]-a[,3]
        Nei.tree=subset(Nei.tree,Size>0)
        Nei.tree=subset(Nei.tree,Distance>0)
        Nei.tree
        Simpn=sum(Nei.tree[,3])
        Nei.tree1=subset(Nei.tree,x>=a[,1]&y>a[,2])####将Nei.tree划分到四个象限
        Nei.tree2=subset(Nei.tree,x>a[,1]&y<=a[,2])
        Nei.tree3=subset(Nei.tree,x<=a[,1]&y<a[,2])
        Nei.tree4=subset(Nei.tree,x<a[,1]&y>=a[,2])
        Simpn1=sum(Nei.tree1[,3])
        Simpn2=sum(Nei.tree2[,3])
        Simpn3=sum(Nei.tree3[,3])
        Simpn4=sum(Nei.tree4[,3])
        simp_wei=sum((Simpn1/Simpn)^2,(Simpn2/Simpn)^2,(Simpn3/Simpn)^2,(Simpn4/Simpn)^2)
        if(is.nan(simp_wei)==T)(simp_wei=0.25)
        simp_wei
      }
      #####计算尺度依赖加权荫蔽度
      S=Scale.dependence.S.single(a,b,scale,MI)
      Levins_Simpson=Scale.dependence.Simpson(a,b,scale)
      a=S$a
      Neighbourhood=S$Neighbourhood
      Scale_dependence_S=S$Scale_dependence_S
      Scale_dependence_Wei_S=Scale_dependence_S*(0.25/Levins_Simpson)
      #Scale_dependence_Wei_S=Scale_dependence_Wei_S/(Scale_dependence_Wei_S+1)
      outcome=list(a=a,Neighbourhood=Neighbourhood,Scale_dependence_S=Scale_dependence_S,Levins_Simpson=Levins_Simpson,Scale_dependence_Wei_S=Scale_dependence_Wei_S)
      outcome
    }
    d=matrix(NA,nrow(a),3)
    pb=tkProgressBar("Progress","Percent complete %", 0, 100) 
    star_time=Sys.time()
    ## 记录程序开始时间 
    for(j in 1:nrow(a))
    {
      d[j,]=cbind(as.matrix(a[j,1:2]),as.matrix(Scale.dependence.Wei_S.single(a[j,],b,scale,MI)$Scale_dependence_Wei_S))
      info=sprintf("Percent complete %d%%", round(j*100/nrow(a))) 
      ## 设置进度条的完成度
      setTkProgressBar(pb, j*100/nrow(a), sprintf("Progress (%s)", info),info)  
      ## 设置进度条         
    }
    end_time =Sys.time() 
    ## 记录程序结束时间
    close(pb)  
    run_time = end_time - star_time 
    ## 计算程序运行时间
    colnames(d)=c("x","y","Scale_dependence_Wei_S")
    rownames(d)=1:nrow(a)
    d=as.data.frame(d)
    d
  }
  